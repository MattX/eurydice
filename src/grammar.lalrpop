use std::str::FromStr;
use crate::ast::{WithRange, Expression, DistributionSpec, UnaryOp, BinaryOp, Statement, Block, MetaStatement};
use crate::typecheck::StaticType;

grammar;

match {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"#[^\n\r]*[\n\r]*" => { }, // Skip `# comments`
    _
}

pub Program: Vec<MetaStatement> = {};

pub MetaStatement: MetaStatement = {
    ":type" <e:Expr> => MetaStatement::Type(e),
    ":out" <e:Expr> => MetaStatement::Out(e),
    <s:Statement> => MetaStatement::Statement(s),
};

pub Statement: WithRange<Statement> = {
    <s:Expr> ";" => WithRange::new(s.range.start, s.range.end, Statement::Expression(s)),
    <start: @L> <id_start: @L> <id:Identifier> <id_end: @L> "=" <e:Expr> <end: @L> ";" => 
        WithRange::new(start, end, Statement::Let { name: WithRange::new(id_start, id_end, id), value: e }),
    <start: @L> <id_start: @L> <id:Identifier> <id_end: @L> "<-" <e:Expr> <end: @L> ";" => 
        WithRange::new(start, end, Statement::SampleLet { name: WithRange::new(id_start, id_end, id), distribution: e }),
    <start: @L> "def" <id_start: @L> <id:Identifier> <id_end: @L> "(" <args:Comma<SingleArg>> ")" "{" <b:Block> "}" <end: @L> => 
        WithRange::new(start, end, Statement::FunctionDefinition { name: WithRange::new(id_start, id_end, id), args, body: b }),
};

pub Block: Block = {
    <ss:Statement*> <expr:Expr> => Block { statements: ss, return_value: expr },
}

pub Expr: WithRange<Expression> = {
    <start: @L> <e:ExprInner> <end: @R> => WithRange::new(start, end, e),
};

pub ExprInner: Expression = {
    #[precedence(level="0")]
    <ds:DistributionSpec> => Expression::Distribution(ds),
    "(" <e:Expr> ")" => e.value,
    <l:List> => Expression::List(l),
    <id_start: @L> <id:Identifier> <id_end: @R> "(" <args:Comma<Expr>> ")" =>
        Expression::FunctionCall { name: WithRange::new(id_start, id_end, id), args },
    <id:Identifier> => Expression::Reference(id),
    #[precedence(level="1")] #[assoc(side="left")]
    <op_start: @L> <o:UnaryOp> <op_end: @R> <start: @L> <e:ExprInner> <end: @R> =>
        Expression::UnaryOp { 
            op: WithRange::new(op_start, op_end, o),
            operand: Box::new(WithRange::new(start, end, e))
        },
    #[precedence(level="2")] #[assoc(side="right")]
    <left_start: @L> <left:ExprInner> <left_end: @R>
    <op_start: @L> <o:BinaryOp> <op_end: @R>
    <right_start: @L> <right:ExprInner> <right_end: @L> => Expression::BinaryOp { 
            op: WithRange::new(op_start, op_end, o),
            left: Box::new(WithRange::new(left_start, left_end, left)),
            right: Box::new(WithRange::new(right_start, right_end, right))
        },
};

pub DistributionSpec: DistributionSpec = {
    <n:Num> => DistributionSpec::Constant(n),
    "d" <sides:Num> => DistributionSpec::Dice { repeat: 1, sides },
    <repeat:Num> "d" <sides:Num> => DistributionSpec::Dice { repeat, sides },
};

pub List: Vec<WithRange<Expression>> = {
    "[" <es:Comma<Expr>> "]" => es,
}

pub SingleArg: (String, StaticType) = {
    <id:Identifier> ":" <t:StaticType> => (id, t),
};

pub StaticType: StaticType = {
    "int" => StaticType::Int,
    "list" => StaticType::List,
    "dist" => StaticType::Dist,
};

// TOOD: avoid unwrap here
Num: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();
Identifier: String = <s:r"(d[a-zA-Z_]|[a-ce-zA-Z_])[a-zA-Z0-9_]*"> => s.to_string();
UnaryOp: UnaryOp = {
    "-" => UnaryOp::Negate,
    "!" => UnaryOp::Invert,
};
BinaryOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::Ne,
    "<" => BinaryOp::Lt,
    "<=" => BinaryOp::Le,
    ">" => BinaryOp::Gt,
    ">=" => BinaryOp::Ge,
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
