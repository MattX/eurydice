use std::str::FromStr;
use crate::ast::{WithRange, Expression, UnaryOp, BinaryOp, Statement, ListLiteralItem, ListLiteral,
                 FunctionCallItem, FunctionDefinitionItem, apply_string_escapes,
                 make_function_definition, make_function_call};
use crate::typecheck::StaticType;

grammar;

match {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"\\[^\\]*\\" => { }, // Skip `\ comments \`
    _
}

pub Body: Vec<WithRange<Statement>> = {
    <ss:Statement*> => ss,
};

pub Statement: WithRange<Statement> = {
    <start: @L> <s:StatementInner> <end: @R> => WithRange::new(start, end, s),
};

pub StatementInner: Statement = {
    <id_start: @L> <id:VariableIdentifier> <id_end: @L> ":" <e:Expr> => 
        Statement::Assignment { name: WithRange::new(id_start, id_end, id), value: e },
    <fd:FunctionDefinition> => fd,
    "output" <e:Expr> <n:OutputName?> => Statement::Output { value: e, named: n },
    "result: " <e:Expr> => Statement::Return { value: e },
    "set" => todo!(),
};

pub Block: Vec<WithRange<Statement>> = {
    <ss:Statement*> => ss,
};

pub Expr: WithRange<Expression> = {
    <start: @L> <e:ExprInner> <end: @R> => WithRange::new(start, end, e),
};

pub ExprInner: Expression = {
    #[precedence(level="0")]
    "(" <e:Expr> ")" => e.value,
    <l:List> => Expression::List(l),
    <fc:FunctionCall> => fc,
    <id:VariableIdentifier> => Expression::Reference(id),
    #[precedence(level="1")] #[assoc(side="left")]
    <op_start: @L> <o:UnaryOp> <op_end: @R> <start: @L> <e:ExprInner> <end: @R> =>
        Expression::UnaryOp { 
            op: WithRange::new(op_start, op_end, o),
            operand: Box::new(WithRange::new(start, end, e))
        },

    // And now get ready for all the binary operators
    // Yes there is probably a better way to do this. 
    #[precedence(level="2")] #[assoc(side="left")]
    <left_start: @L> <left:ExprInner> <left_end: @R>
    <op_start: @L> <o:BinaryOp0> <op_end: @R>
    <right_start: @L> <right:ExprInner> <right_end: @L> =>
        Expression::BinaryOp { 
            op: WithRange::new(op_start, op_end, o),
            left: Box::new(WithRange::new(left_start, left_end, left)),
            right: Box::new(WithRange::new(right_start, right_end, right))
        },
    #[precedence(level="3")] #[assoc(side="left")]
    <left_start: @L> <left:ExprInner> <left_end: @R>
    <op_start: @L> <o:BinaryOp1> <op_end: @R>
    <right_start: @L> <right:ExprInner> <right_end: @L> =>
        Expression::BinaryOp { 
            op: WithRange::new(op_start, op_end, o),
            left: Box::new(WithRange::new(left_start, left_end, left)),
            right: Box::new(WithRange::new(right_start, right_end, right))
        },
    #[precedence(level="4")] #[assoc(side="left")]
    <left_start: @L> <left:ExprInner> <left_end: @R>
    <op_start: @L> <o:BinaryOp2> <op_end: @R>
    <right_start: @L> <right:ExprInner> <right_end: @L> =>
        Expression::BinaryOp { 
            op: WithRange::new(op_start, op_end, o),
            left: Box::new(WithRange::new(left_start, left_end, left)),
            right: Box::new(WithRange::new(right_start, right_end, right))
        },
    #[precedence(level="5")] #[assoc(side="left")]
    <left_start: @L> <left:ExprInner> <left_end: @R>
    <op_start: @L> <o:BinaryOp3> <op_end: @R>
    <right_start: @L> <right:ExprInner> <right_end: @L> =>
        Expression::BinaryOp { 
            op: WithRange::new(op_start, op_end, o),
            left: Box::new(WithRange::new(left_start, left_end, left)),
            right: Box::new(WithRange::new(right_start, right_end, right))
        },
    #[precedence(level="6")] #[assoc(side="left")]
    <left_start: @L> <left:ExprInner> <left_end: @R>
    <op_start: @L> <o:BinaryOp4> <op_end: @R>
    <right_start: @L> <right:ExprInner> <right_end: @L> =>
        Expression::BinaryOp { 
            op: WithRange::new(op_start, op_end, o),
            left: Box::new(WithRange::new(left_start, left_end, left)),
            right: Box::new(WithRange::new(right_start, right_end, right))
        },
};

pub OutputName: WithRange<String> = {
    "named" <start: @L> <l:r#""(\\\\|\\"|[^"\\])*""#> <end: @R> =>
        WithRange::new(start, end, apply_string_escapes(&l[1..l.len()-1]).into()),
}

pub List: ListLiteral = {
    "{" <es:Comma<ListItemWithRepeat>> "}" => ListLiteral { items: es },
}

pub ListItemWithRepeat: (ListLiteralItem, i32) = {
    <e:ListItem> <r:Repeat?> => (e, r.unwrap_or(1)),
};

pub Repeat: i32 = {
    ":" <n:Num> => n
};

pub ListItem: ListLiteralItem = {
    <e:Expr> => ListLiteralItem::Expr(e),
    <start:Expr> ".." <end:Expr> => ListLiteralItem::Range(start, end),
};

pub FunctionCall: Expression = {
    // This is kind of ugly, but if you try to have FunctionCallItem = Expr | Word, the parser
    // will choke on consecutive expressions. So we say an item is a word or an expression followed
    // by a word, and then we allow an optional last expression.
    "[" <items:FunctionCallItem+> <last:Expr?> "]" => {
        let mut all_items = items.into_iter().flatten().collect::<Vec<_>>();
        if let Some(last) = last {
            all_items.push(WithRange::new(last.range.start, last.range.end, FunctionCallItem::Expr(last.value)));
        }
        make_function_call(all_items)
    }
};

pub FunctionCallItem: Vec<WithRange<FunctionCallItem>> = {
    <start: @L> <w:Word> <end: @R> => vec![WithRange::new(start, end, FunctionCallItem::Word(w))],
    <e:Expr> <start_word: @L> <w:Word> <end_word: @R> =>
        vec![WithRange::new(e.range.start, e.range.end, FunctionCallItem::Expr(e.value)),
             WithRange::new(start_word, end_word, FunctionCallItem::Word(w))],
};

pub FunctionDefinition: Statement = {
    "function:" <items:FunctionDefinitionItem+> "{" <b:Block> "}" => make_function_definition(items, b),
};

pub FunctionDefinitionItem: WithRange<FunctionDefinitionItem> = {
    <start: @L> <w:Word> <end: @R> => WithRange::new(start, end, FunctionDefinitionItem::Word(w)),
    <start: @L> <id:SingleArg> <end: @R> => WithRange::new(start, end, id),
};

pub SingleArg: FunctionDefinitionItem = {
    <id:VariableIdentifier> ":" <t:StaticType> => FunctionDefinitionItem::ArgWithType(id, t),
};

pub StaticType: StaticType = {
    "n" => StaticType::Int,
    "s" => StaticType::List,
    "d" => StaticType::Dist,
};

// TOOD: avoid unwrap here
Num: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();
VariableIdentifier: String = <s:r"[A_Z][A-Z_]*"> => s.to_string();
Word: String = <s:r"[a-z][a-z_]+"> => s.to_string();
UnaryOp: UnaryOp = {
    "-" => UnaryOp::Negate,
    "!" => UnaryOp::Invert,
    "#" => UnaryOp::Length,
    "d" => UnaryOp::D,
};
BinaryOp0: BinaryOp = {
    "d" => BinaryOp::D,
    "@" => BinaryOp::At,
};
BinaryOp1: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
};
BinaryOp2: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
};
BinaryOp3: BinaryOp = {
    "&" => BinaryOp::And,
    "|" => BinaryOp::Or,
}
BinaryOp4: BinaryOp = {
    "=" => BinaryOp::Eq,
    "!=" => BinaryOp::Ne,
    "<" => BinaryOp::Lt,
    "<=" => BinaryOp::Le,
    ">" => BinaryOp::Gt,
    ">=" => BinaryOp::Ge,
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
